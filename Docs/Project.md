Specification for a Secure, Self-Contained, FUSE-Backed File Server in Rust1. System Architecture and Technology StackThis document provides a comprehensive technical specification for the design and implementation of a secure, internet-facing file server system. The system is architected to be entirely self-contained within the Rust programming ecosystem, eliminating dependencies on external applications or services for core functionality. It will provide standard Create, Read, Update, and Delete (CRUD) operations on a hierarchical file structure, authenticated via the OAuth 2.0 protocol, with all data transport secured by Transport Layer Security (TLS). The client-side component will present the remote storage to the end-user's operating system as a transparently mounted local volume.1.1. High-Level Architectural OverviewThe system is logically divided into two distinct but tightly integrated components: the Server and the Client. This separation of concerns allows for independent development and testing while defining a clear, secure communication protocol between them.1.1.1. The Server ComponentThe server is a monolithic, asynchronous Rust binary designed to be deployed on internet-accessible infrastructure. It concurrently fulfills two critical roles, functioning as both a Resource Server and an Authorization Server.Resource Server: In this capacity, the server exposes a secure, RESTful API over HTTPS. This API is the sole mechanism for interacting with the underlying file storage. It provides endpoints for all file and directory manipulation, including creation, retrieval, updating, deletion, and metadata inspection. Every request to these endpoints must be accompanied by a valid OAuth 2.0 access token for authorization.Authorization Server: The server also implements the necessary components of the OAuth 2.0 protocol to act as a standalone identity and access management provider. It is responsible for authenticating users (e.g., via username and password), managing client registrations, and issuing cryptographically signed JSON Web Tokens (JWTs) that serve as access tokens for the Resource Server API.1.1.2. The Client ComponentThe client is a native user-space application that leverages the Filesystem in Userspace (FUSE) framework. Its primary function is to create a virtual filesystem that acts as a proxy to the remote server. When a user or application performs a standard filesystem operation (e.g., listing a directory with ls, reading a file with cat, or writing to a file with echo > file) on the mounted directory, the operating system kernel intercepts this call and forwards it to the FUSE client. The client is then responsible for translating this low-level filesystem request into a high-level, authenticated HTTPS API call to the server.1.1.3. System Interaction FlowThe lifecycle of a typical user interaction is as follows:Initial Authentication: Upon its first execution, the client application initiates an OAuth 2.0 Authorization Code grant flow. It directs the user to authenticate with the server via a web browser.Token Acquisition: After successful authentication and user consent, the server provides the client with a short-lived access token and a long-lived refresh token. The client securely stores these tokens in the operating system's native credential manager.Filesystem Operation: A user interacts with the mounted volume. For example, they attempt to read ~/mounted_drive/documents/report.txt.Request Translation: The FUSE client intercepts the read operation. It constructs a corresponding API request (e.g., GET /documents/report.txt) to the remote server.Authenticated API Call: The client retrieves the stored access token and includes it in the Authorization: Bearer <token> header of the HTTPS request.Server-Side Processing: The server receives the request. Its authorization middleware validates the access token's signature, expiration, and claims. If valid, the server performs the requested file operation on its internal storage backend.Response and Translation: The server returns the result of the operation (e.g., the contents of report.txt) in the HTTPS response.Kernel Response: The FUSE client receives the API response and translates it into the format expected by the kernel, providing the file's contents back to the original calling application. The entire process is transparent to the end-user and their applications.Token Refresh: If an API call fails with a 401 Unauthorized status, indicating an expired access token, the client automatically uses its refresh token to obtain a new access token from the server and retries the original request.1.2. Technology Stack RationaleThe primary constraint of this project is its reliance on a self-contained Rust ecosystem. This dictates a careful selection of libraries (crates) that are implemented in pure Rust or whose dependencies are managed entirely by the Cargo build system, thereby avoiding reliance on system-level libraries or external runtimes.1.2.2. Web Framework: AxumWhile the Rust ecosystem offers several high-quality web frameworks, including Actix Web, Rocket, and Axum 1, Axum is selected as the foundational web framework for the server component.Actix Web is renowned for its exceptional raw performance in benchmarks, and Rocket is praised for its developer-friendly, declarative macro system.2 However, the server in this specification is not a simple microservice but a complex application with dual responsibilities: serving a file API and managing OAuth 2.0 authentication flows. For such a system, architectural clarity, modularity, and maintainability are paramount.Axum's design, which is built upon the tower and tower-http ecosystem of services and middleware, provides unparalleled composability.5 This architecture allows for the clean separation of concerns. For instance, the security-critical token validation logic can be implemented as a reusable, independently testable tower middleware. This middleware can then be applied selectively to the file API routes without entangling the authentication logic with the file operation handlers. This modularity simplifies development, enhances testability, and makes the security posture of the application easier to audit and reason about. Furthermore, Axum's commitment to 100% safe Rust, enforced by #![forbid(unsafe_code)], directly aligns with the security-first requirements of an internet-facing server.51.2.3. Transport Layer Security (TLS): rustlsAll communication between the client and server must be encrypted. The rustls crate is the definitive choice for implementing TLS.Traditionally, many applications would link against the system's OpenSSL library.6 This approach, however, introduces a dependency on C code and forfeits Rust's primary security advantage: memory safety. rustls is a modern TLS implementation written in pure, memory-safe Rust.7 This design choice eliminates an entire class of critical security vulnerabilities, such as the infamous Heartbleed bug, which stemmed from memory management errors in C-based libraries.7The rustls project is backed by the Internet Security Research Group (ISRG), the organization behind Let's Encrypt, and has received significant investment from major technology companies like Amazon Web Services and Google, ensuring its continued maintenance and development.7 Performance benchmarks show that rustls is highly competitive with, and in some server-side scenarios, outperforms traditional libraries like OpenSSL.8 It supports modern TLS versions (1.2 and 1.3) and cryptographic standards while explicitly rejecting obsolete and insecure protocols and ciphers.10 The server will integrate rustls using its default, high-performance cryptographic provider, aws-lc-rs, which is a Rust wrapper around AWS Libcrypto.101.2.4. OAuth 2.0 Provider: oauth-provider-rsThe requirement for the server to also function as a self-contained OAuth 2.0 Authorization Server presents the most significant technical challenge. While the Rust ecosystem has mature and robust libraries for implementing OAuth 2.0 clients (such as the oauth2 crate 13), implementing a compliant and secure OAuth 2.0 provider is a far more complex undertaking. Building one from scratch based on the RFC specifications is a massive effort that is highly prone to subtle but critical security flaws.15The oauth-provider-rs crate is identified as the only available option within the Rust ecosystem that is specifically designed for this purpose.16 It provides essential features out-of-the-box, including support for the Authorization Code Flow with PKCE, JWT-based token management, and, crucially, direct integration with Axum via a router extension.16It is critical to acknowledge that this crate is in an early alpha stage of development (e.g., v0.1.0-alpha.7).16 Adopting it is a strategic decision that enables the project to meet its "self-contained" requirement, which would otherwise be infeasible. This decision necessitates a robust risk mitigation strategy. The project plan must allocate specific time for:Thoroughly auditing the crate's source code.Developing an extensive suite of integration tests that validate its OAuth 2.0 flows against the relevant RFCs.Actively monitoring the crate's development and being prepared to contribute fixes or workarounds for any identified issues.1.2.5. FUSE Implementation: fuserFor the client component, the fuser crate is the standard and most mature library for creating FUSE filesystems in Rust.17 It is a complete rewrite of the C libfuse library, designed to provide an idiomatic Rust interface to the kernel's FUSE subsystem.17The core of the fuser library is the Filesystem trait.18 A developer implements this trait, providing the logic for each filesystem operation (e.g., lookup, getattr, read, write). The fuser crate handles all the low-level, complex communication with the kernel driver, allowing the developer to focus purely on the logic of their filesystem—in this case, translating filesystem operations into API calls. Its comprehensive documentation and the availability of non-trivial examples provide a solid foundation for the client's implementation.171.2.6. Token Handling and CryptographyJSON Web Tokens (JWT): The jsonwebtoken crate will be used for all JWT operations.20 It is a well-established, widely-used crate for creating, signing, decoding, and validating JWTs in a strongly-typed manner. The Authorization Server will use it to sign access tokens, and the Resource Server's authentication middleware will use it to validate them.Password Hashing: To securely store user credentials, the argon2 crate will be employed.21 Argon2 is the winner of the Password Hashing Competition and is the current industry best practice, offering strong resistance to both GPU-based and side-channel attacks.ComponentSelected CrateKey AlternativesJustification for SelectionAssociated Risks & Mitigation StrategyWeb Frameworkaxum 5actix-web 3, rocket 4Superior architectural modularity via the tower ecosystem, which is ideal for separating complex concerns like API logic and authentication. Promotes clean, maintainable, and auditable code. 100% memory-safe implementation.5Minimal. Axum is a mature, production-ready framework backed by the Tokio project.TLS Implementationrustls 7System openssl bindingsPure Rust, memory-safe implementation eliminates an entire class of C-based vulnerabilities. Aligns with the core security philosophy of Rust. Strong industry backing and excellent performance.7Minimal. rustls is a production-grade, widely adopted library.OAuth 2.0 Provideroauth-provider-rs 16Build from scratch; external services (e.g., Ory Hydra 22)The only available Rust-native crate that provides server-side OAuth 2.0 functionality with direct Axum integration. Building from scratch is infeasible and insecure. External services violate the "self-contained" requirement.High. The crate is in an early alpha stage. Mitigation: Allocate project time for source code review, extensive compliance and security testing against RFCs, and be prepared to contribute patches upstream. Treat integration as an R&D task, not a simple dependency addition.FUSE Libraryfuser 17polyfuse 23The most mature, well-documented, and widely adopted FUSE implementation in Rust. Provides a clean, trait-based interface that abstracts away kernel communication complexities.18Minimal. fuser is a stable and well-maintained crate.JWT Handlingjsonwebtoken 20jwt-simple 21, biscuit 24The de facto standard for JWT handling in Rust. It is feature-complete, actively maintained, and widely trusted in the community.Minimal. The crate is mature and focuses on a well-defined standard.Password Hashingargon2 21bcrypt, scryptArgon2 is the current industry best practice for password hashing, offering superior resistance to modern hardware-based cracking techniques compared to older algorithms. Pure Rust implementation avoids FFI complexities.Minimal. The argon2 crate is a stable and correct implementation of the standard.2. The Secure API Server (Resource Server)The server component, acting as the Resource Server, is the authoritative backend for all file system data and metadata. Its design prioritizes security, clarity of the API contract, and robust implementation practices.2.1. API Endpoint DefinitionThe API is designed to be RESTful, stateless, and resource-oriented. It operates over HTTPS exclusively. Paths are used to identify file and directory resources within a hierarchical structure. Request and response bodies for structured data (e.g., directory listings, error messages) will use the application/json media type, while file content will be transferred as application/octet-stream. All endpoints, unless otherwise specified, require a valid JWT in the Authorization: Bearer <token> header.HTTP MethodURI PatternDescriptionAuthorization HeaderRequest BodySuccess Response (Code & Body)Error Responses (Code & Description)GET/{path:.*}Retrieves the content of a file or lists the entries of a directory.RequiredNone200 OK application/octet-stream (for files) or application/json (for directories). Directory listing is a JSON array of objects, each with name, type, size, and modified_time.401 Unauthorized: Invalid or missing token.
404 Not Found: Path does not exist.
403 Forbidden: Insufficient permissions.HEAD/{path:.*}Retrieves the metadata of a file or directory without the content body.RequiredNone200 OK with headers like Content-Length, Last-Modified, and a custom X-File-Type (file or directory).401 Unauthorized
404 Not Found
403 ForbiddenPUT/{path:.*}Creates a new file or overwrites an existing file at the specified path.Requiredapplication/octet-stream with the file content.201 Created: If a new file was created.
200 OK: If an existing file was overwritten.401 Unauthorized
400 Bad Request: Path is invalid or refers to a directory.
403 Forbidden
413 Payload Too LargePOST/{path:.*}Creates a new directory at the specified path.RequiredNone201 Created401 Unauthorized
400 Bad Request: Path is invalid.
409 Conflict: A file or directory already exists at the path.
403 ForbiddenDELETE/{path:.*}Deletes the file or directory at the specified path.RequiredNone204 No Content401 Unauthorized
404 Not Found
400 Bad Request: Cannot delete a non-empty directory.
403 Forbidden2.2. Server Implementation with Axum and rustlsThe server's entry point will be an asynchronous main function, leveraging the tokio runtime.2.2.1. Application InitializationThe core of the application will be an Axum Router, which declaratively maps HTTP methods and URI patterns to handler functions.25 This router will be configured with routes for both the file API endpoints defined above and the OAuth 2.0 endpoints specified in Section 3.2.2.2. TLS TerminationTo ensure all communication is encrypted, the server will not bind to a standard TCP listener. Instead, it will use the axum-server crate, which provides seamless integration with rustls.26 The startup sequence will involve:Loading a PEM-formatted TLS certificate chain and a PKCS#8 encoded private key from the filesystem.27Creating a rustls::ServerConfig instance with this keypair and configuring it with modern, secure cipher suites and no client certificate authentication.28Instantiating an axum_server::tls_rustls::RustlsConfig from the rustls configuration.30Calling axum_server::bind_rustls with the server's address and the RustlsConfig. This creates a server that will perform the TLS handshake for every new connection before passing the decrypted stream to Axum's router.26This approach ensures that TLS is handled directly within the Rust application, fulfilling the "self-contained" requirement without needing a reverse proxy like Nginx.62.2.3. State ManagementApplication-wide state, such as a handle to the internal storage engine, configuration parameters, and the JWT signing keys, will be managed using Axum's State extractor. To ensure this state can be safely shared across the multiple worker threads that Axum may spawn, it will be wrapped in an Arc (Atomically Referenced Counter).25 This allows for efficient, thread-safe read access from all handlers.2.3. Token-Based Authorization MiddlewareAuthentication will be implemented not as a traditional middleware layer, but as an Axum extractor by implementing the FromRequestParts trait.31 This approach offers greater clarity and explicitness; any handler that requires authentication will declare the extractor in its function signature, making the security requirement immediately obvious upon code inspection.The AuthenticatedUser extractor will perform the following steps:Header Extraction: It will inspect the incoming request for an Authorization header and expect a value conforming to the Bearer <token> scheme. The axum-extra crate's TypedHeader can be used for this purpose.31 If the header is missing or malformed, the extractor will immediately return a rejection, which Axum translates into a 401 Unauthorized response.Token Validation: The extracted token string will be passed to the jsonwebtoken::decode function. This function requires the token, a decoding key (the public key corresponding to the private key used by the Authorization Server), and a Validation struct.20 The validation will be configured to automatically verify:The token's cryptographic signature.The exp (expiration) claim against the current time.The iss (issuer) claim to ensure the token was issued by this server.The aud (audience) claim to ensure the token was intended for use with the file server API.Payload Extraction: If validation is successful, the function returns the decoded token data, including the claims payload. The extractor will parse the sub (subject) claim, which contains the unique user ID.Principal Creation: The extractor will return an AuthenticatedUser struct containing the validated user ID. This struct can then be used by the API handler to perform actions on behalf of that specific user.Rejection: If any part of the validation fails (e.g., invalid signature, expired token), the decode function will return an error. The extractor will catch this error and return a rejection, resulting in a 401 Unauthorized response to the client.2.4. Internal Storage EngineIn adherence to the "no external dependencies" constraint, the server will manage all user data, metadata, and file content on the local filesystem within a designated data root directory. This engine must be designed for asynchronous access and concurrency safety.2.4.1. Directory StructureA structured layout within the data root directory will be used to organize all persistent state:<data_root>/users/: This directory will contain user account information. Each file will be named after a unique user ID (e.g., user-123.json) and will contain a serialized JSON object with the username and the Argon2-hashed password.<data_root>/clients/: This directory will store registered OAuth 2.0 client configurations. Each file (e.g., client-abc.json) will contain the client_id, a list of valid redirect_uris, and other client metadata.<data_root>/inodes/: This directory will serve as the metadata store for the filesystem. Inspired by the simple.rs FUSE example, each file will be named after its inode number (e.g., 1.json for the root directory).19 The file will contain a serialized InodeAttributes struct, storing metadata such as file type, size, permissions, ownership (UID/GID), and timestamps.<data_root>/content/: This directory will store the actual file data. The filename for each content file will be its corresponding inode number (e.g., 27 for the content of the file represented by inode 27). Directories and symbolic links will not have a corresponding entry in this directory; their "content" is stored within their inode metadata.2.4.2. Concurrency and Asynchronous I/OAll file I/O operations must be performed asynchronously using the tokio::fs module to prevent blocking the server's worker threads. To prevent race conditions when modifying metadata (e.g., two requests trying to write to the same directory simultaneously), appropriate synchronization mechanisms must be used. A potential strategy involves using a tokio::sync::RwLock to guard an in-memory map of file-level locks, ensuring that operations on the same file or directory are serialized correctly.3. The Integrated OAuth 2.0 Authorization ServerThe server's secondary role is to function as a complete, self-hosted OAuth 2.0 Authorization Server. This component is responsible for authenticating users and issuing the JWTs that the Resource Server consumes.3.1. OAuth 2.0 Grant Flow SpecificationThe server will implement a single, highly secure grant flow: the Authorization Code Grant with Proof Key for Code Exchange (PKCE), as defined in RFC 7636.This choice is deliberate. The FUSE client is a "public client" in OAuth 2.0 terminology, as it is a native application running on a user's machine and cannot be trusted to keep a client_secret confidential.32 The standard Authorization Code flow without PKCE is vulnerable to authorization code interception attacks in this scenario. PKCE mitigates this threat by requiring the client to generate a secret (code_verifier) and send a transformed version of it (code_challenge) in the initial authorization request. The Authorization Server stores this challenge. When the client later exchanges the authorization code for a token, it must also present the original code_verifier. The server then verifies that the verifier matches the stored challenge, ensuring that only the client that initiated the flow can complete it.33 This flow is now considered the best practice for all types of clients, including native, mobile, and single-page web applications.3.2. Implementation of Core Endpoints with oauth-provider-rsThe oauth-provider-rs crate is designed to simplify the implementation of the required OAuth 2.0 endpoints by integrating directly with Axum.16 The server will configure and mount the routes provided by this crate./authorize Endpoint: This is the user-facing endpoint that initiates the authorization process. Its handler will be responsible for:Validating the incoming request from the client, including the client_id, redirect_uri, scope, and the PKCE code_challenge.Checking if the user is already authenticated (e.g., via a session cookie). If not, it will present the user with a login page (served as a standard Axum HTML response).After successful login, it will display a consent screen, detailing the permissions (scopes) the client application is requesting.Upon user consent, it will generate a short-lived, single-use authorization code, associate it with the user's session and the PKCE challenge, and redirect the user's browser back to the client's registered redirect_uri with the code as a query parameter./token Endpoint: This is the backend endpoint used by the client application. Its handler will:Receive a POST request from the client containing the grant_type (authorization_code), the authorization code, the redirect_uri, the client_id, and the PKCE code_verifier.Validate that the authorization code is valid, has not expired, and was issued to the provided client_id.Perform the PKCE verification by transforming the received code_verifier and comparing it to the code_challenge stored when the code was issued.If all checks pass, it will invalidate the authorization code to prevent reuse and proceed to issue new tokens (see Section 3.4).3.3. User and Client Credential ManagementThe oauth-provider-rs crate is designed to be storage-agnostic, requiring the developer to provide an implementation of its storage trait.16 A custom implementation will be created to interface with the file-based storage engine defined in Section 2.4.User Store: The implementation will read from and write to the <data_root>/users/ directory. When a user attempts to log in at the /authorize endpoint, the server will retrieve their record, hash the provided password using argon2, and compare it in constant time to the stored hash.Client Store: The implementation will manage OAuth client registrations in the <data_root>/clients/ directory. This allows for programmatic or administrative registration of clients (like the official FUSE client) that are permitted to use the OAuth 2.0 service.3.4. JWT Issuance and LifecycleUpon a successful request to the /token endpoint, the Authorization Server will generate two tokens.Access Token: A JWT will be created and signed using the jsonwebtoken crate with a private key (e.g., ES256). The JWT's payload (claims) will contain standard fields essential for the Resource Server's validation process:iss (Issuer): A URL identifying the server itself.sub (Subject): The unique, non-reassignable ID of the authenticated user.aud (Audience): A string identifying the file server API (e.g., api://fileserver).exp (Expiration Time): A Unix timestamp for a short-lived expiration, typically 15-60 minutes, to limit the impact of a leaked token.iat (Issued At): A Unix timestamp indicating when the token was issued.scope: A space-separated string of granted permissions (e.g., file.read file.write).Refresh Token: Alongside the access token, the server will issue a long-lived, opaque (non-JWT) refresh token. This will be a cryptographically secure random string. A record of this refresh token, its associated user and client, and its own expiration date (e.g., 30 days) will be stored securely on the server. The client can later present this refresh token to the /token endpoint (with grant_type=refresh_token) to obtain a new access token without requiring the user to re-authenticate.4. The FUSE Client ImplementationThe client application is the bridge between the operating system's virtual filesystem (VFS) interface and the server's RESTful API. Its goal is to make interaction with the remote storage completely transparent to the user and their applications.4.1. FUSE Principles and the fuser CrateFUSE allows programs running in user space to export a virtual filesystem to the kernel.17 The fuser client will register a mount point with the kernel. When any process tries to access a path within this mount point, the kernel will not handle the operation itself. Instead, it will serialize the request (e.g., "read 1024 bytes from file X at offset 512") and send it to the fuser client. The client's implementation of the fuser::Filesystem trait will receive this request, process it, and send a reply back to the kernel, which then completes the original system call.184.2. Mapping Filesystem Operations to API CallsThe core logic of the client resides in its implementation of the fuser::Filesystem trait methods. Each method will be responsible for translating a specific VFS operation into one or more authenticated API calls. An HTTP client, such as reqwest, will be used for all communication with the server.fuser::Filesystem MethodKernel Operation TriggerCorresponding API Call(s)Key Implementation Notesgetattrstat, ls -lHEAD /{path}This is a critical optimization. Use HEAD to fetch metadata without the file body. Parse Content-Length, Last-Modified, and X-File-Type headers from the response and populate a fuser::FileAttr struct.lookupPath resolutionHEAD /{parent}/{name}Similar to getattr, but used by the kernel to verify a path component exists and get its attributes. The client should return the attributes for the looked-up entry.readdirls, findGET /{path}Make a GET request to the directory path. The server will respond with a JSON array of directory entries. The client must parse this array and add each entry (including . and ..) to the ReplyDirectory buffer.readcat, file open, cpGET /{path} with Range headerThe read method provides an offset and size. The client must construct an HTTP Range header (e.g., Range: bytes=offset-offset+size-1) to fetch only the required portion of the file. The response body is then written directly to the reply buffer.writeecho > file, file savePUT /{path}The write method provides a buffer of data to be written at a specific offset. The client will need to either use a PUT request with the full file content or a PATCH request if the API supports partial updates. For simplicity, this spec assumes a PUT of the entire modified file.create / mknodtouch, > redirectPUT /{path}Create a new, empty file on the server. The server should create the file with zero length.mkdirmkdirPOST /{path}Create a new directory on the server.unlinkrmDELETE /{path}Delete a file on the server.rmdirrmdirDELETE /{path}Delete a directory on the server. The API should enforce that the directory is empty.renamemvMOVE /{source} with Destination header (custom)The API needs a mechanism for atomic renames. A MOVE method with a Destination header is a common REST pattern. The client translates the rename call into this API request.4.3. Client-Side Authentication FlowSince the FUSE client is a command-line/background application, it cannot render a web view for login. It must orchestrate a browser-based flow for the initial user authentication.Start Local Server: On startup, if no valid tokens are found, the client will bind a simple HTTP server to a random, available port on the loopback interface (e.g., 127.0.0.1:61234). This address will be used as the redirect_uri.Construct Authorization URL: The client will generate the PKCE code_verifier and code_challenge. It will then construct the full authorization URL for the server's /authorize endpoint, including its client_id, the local redirect_uri, requested scopes, and the code_challenge.User Interaction: The client will print the authorization URL to the console, instructing the user to copy and paste it into their web browser to log in.Capture Authorization Code: The user authenticates with the server in their browser and grants consent. The server then redirects the user's browser to the local redirect_uri (e.g., http://127.0.0.1:61234/callback?code=...). The client's local server receives this single request, extracts the code from the query parameters, and can then immediately shut down.Token Exchange: With the authorization code in hand, the client makes a direct, secure, backend HTTPS POST request to the server's /token endpoint, including the code and the original code_verifier, to exchange them for an access token and refresh token.4.4. Secure Token Storage and RefreshStoring OAuth tokens in a plaintext file is a major security risk. The client must use the operating system's secure credential storage facility.Secure Storage: The keyring crate will be used for this purpose.21 This crate provides a unified, cross-platform API for interacting with the macOS Keychain, the Windows Credential Manager, and the Freedesktop.org Secret Service on Linux. The client will store the access token and refresh token securely using this service.Token Refresh Logic: The client will implement a reactive token refresh mechanism. The primary flow for an API call will be:Retrieve the access token from the secure store.Make the API request.If the request succeeds, the process is complete.If the request fails with a 401 Unauthorized status, the client assumes the access token has expired. It will then retrieve the refresh token from the secure store and make a request to the /token endpoint to get a new set of tokens.If the token refresh is successful, the client will update the tokens in the secure store and automatically retry the original API request a single time.If the refresh token itself is invalid or expired, the client must fail the filesystem operation and trigger the full re-authentication flow described in Section 4.3.5. System-Wide Security and HardeningA security-first posture must be maintained throughout the development lifecycle. The server is assumed to be a hostile, public-facing target.5.1. Threat Modeling and MitigationPath Traversal: The server must never use a path string from a client request to directly access its local filesystem. All paths must be canonicalized and validated to ensure they resolve to a location within the designated <data_root>/content/ directory and do not contain components like ...Input Validation: All inputs from the client, including headers, JSON payloads, and query parameters, must be strictly validated. This includes checking for expected types, lengths, and character sets to prevent injection attacks and other parsing vulnerabilities.35Dependency Vulnerabilities: The CI/CD pipeline must integrate cargo-audit to continuously scan all dependencies against the RustSec advisory database for known vulnerabilities.35cargo-deny can be used to enforce policies on licenses and duplicate crate versions.Denial of Service (DoS): The server should implement rate limiting, especially on computationally expensive or sensitive endpoints like user login and token issuance, to mitigate brute-force and credential-stuffing attacks. Axum's tower ecosystem has crates available for this purpose.Information Leakage: Error handling must be carefully managed. Production builds should never expose internal application details like stack traces or verbose database errors to the client.35 Generic, logged error messages should be returned instead.5.2. Secure Configuration ManagementSensitive configuration data, including the TLS private key, the JWT signing private key, and any other secrets, must never be hardcoded in the source code or committed to version control.35 They should be loaded at runtime from environment variables or a dedicated, git-ignored configuration file.5.3. Leveraging Rust's Safety GuaranteesThe choice of Rust is a foundational security decision, and its features must be used to their full potential.Minimize unsafe Code: The unsafe keyword bypasses Rust's compile-time safety checks and should be avoided wherever possible. Any necessary use of unsafe (e.g., for FFI in the FUSE client) must be isolated into the smallest possible blocks, thoroughly documented with comments explaining the invariants that must be manually upheld, and subjected to the highest level of code review scrutiny.36Enable Runtime Safety Checks: Integer overflows can lead to subtle but severe security vulnerabilities, such as incorrect length calculations resulting in buffer overflows. While Rust checks for overflows in debug builds, this is disabled by default in release builds for performance. The project's Cargo.toml file must explicitly enable these checks for production builds by setting overflow-checks = true under [profile.release].36Leverage the Type System for Security: Rust's strong, static type system should be used to make invalid states unrepresentable at compile time. For example, instead of passing raw strings or integers for identifiers, newtype wrappers like struct UserId(u64) and struct Inode(u64) should be used. This prevents a developer from accidentally passing a user ID to a function expecting an inode number, a logical error that the compiler can catch automatically.366. Implementation Roadmap and Conclusion6.1. Phased Implementation PlanA phased approach is recommended to manage complexity and mitigate risk, particularly around the integration of the alpha-stage OAuth provider.Phase 1: Core API and Storage: Implement the Axum server with the file-based storage engine. Build and test the unauthenticated CRUD API endpoints for files and directories.Phase 2: Authorization Server Implementation: Integrate the oauth-provider-rs crate. Implement the custom storage backend, the user login and consent UI, and the /authorize and /token endpoints. Conduct rigorous, standalone testing of the OAuth 2.0 flow.Phase 3: API Security Integration: Develop the JWT validation extractor and apply it as a requirement to all the file API endpoints from Phase 1.Phase 4: FUSE Client (Read-Only): Implement the basic FUSE client using fuser. Build the client-side authentication flow for acquiring tokens and the secure storage mechanism using the keyring crate. Implement all read-only filesystem operations (getattr, lookup, readdir, read, etc.).Phase 5: FUSE Client (Read-Write): Implement the remaining write-based filesystem operations (mknod, mkdir, write, unlink, rename, etc.).Phase 6: Hardening and Finalization: Conduct a comprehensive security review of the entire system. Implement robust logging, metrics, and rate limiting. Finalize documentation and prepare for deployment.6.2. Summary of SpecificationThis specification outlines a robust and secure architecture for a file server system that fully adheres to the user's core requirements, most notably the constraint of being entirely self-contained within the Rust ecosystem. The technology stack has been carefully selected to maximize the security and performance benefits of Rust, leveraging memory-safe libraries like rustls and fuser, and a modern, composable web framework in Axum.The primary technical risk—the reliance on the alpha-stage oauth-provider-rs crate—has been identified and is addressed by a mitigation strategy that includes dedicated testing and potential upstream contributions. The detailed API contracts, FUSE-to-API mappings, and phased implementation plan provide an actionable blueprint for development. By following this specification, the resulting system will be a secure, modern, and performant file server that exemplifies the unique strengths of the Rust programming language for building reliable, internet-facing services.